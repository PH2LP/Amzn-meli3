#!/usr/bin/env python3
"""
Amazon Availability Checker usando API INTERNA Glow

Usa requests + Glow API para verificar disponibilidad y fechas de entrega.
Detecta autom√°ticamente FREE delivery vs delivery pago (fastest).
"""
import os
import re
import requests
import random
from datetime import datetime
from typing import Optional, Dict
from bs4 import BeautifulSoup

# Lista de User-Agents para rotar
USER_AGENTS = [
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36',
]

def get_random_user_agent():
    """Retorna un User-Agent aleatorio de la lista"""
    return random.choice(USER_AGENTS)


def check_real_availability_glow_api(asin: str, zipcode: str = None) -> Dict:
    """
    Verifica disponibilidad REAL de un producto en Amazon.com
    usando la API interna "Glow" de Amazon para cambiar zipcode.

    VENTAJAS sobre Selenium:
    - 4x m√°s r√°pido (~5s vs ~20s)
    - No requiere Chrome/ChromeDriver
    - Usa API interna estable
    - Filtra delivery pago vs FREE delivery

    Args:
        asin: ASIN del producto
        zipcode: Zipcode del comprador (default: desde .env BUYER_ZIPCODE)

    Returns:
        Dict con:
        {
            "available": bool,
            "delivery_date": str,
            "days_until_delivery": int,
            "is_fast_delivery": bool,
            "prime_available": bool,
            "in_stock": bool,
            "price": float,
            "error": str or None
        }
    """
    if not zipcode:
        zipcode = os.getenv("BUYER_ZIPCODE", "33172")

    result = {
        "available": False,
        "delivery_date": None,
        "days_until_delivery": None,
        "is_fast_delivery": False,
        "prime_available": False,
        "in_stock": False,
        "price": None,
        "error": None
    }

    session = requests.Session()

    # User-Agent aleatorio para cada request
    user_agent = get_random_user_agent()

    session.headers.update({
        'User-Agent': user_agent,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Cache-Control': 'max-age=0',
    })

    # Configurar proxy si est√° disponible en .env
    proxies = None
    proxy_url = os.getenv("HTTP_PROXY") or os.getenv("HTTPS_PROXY")
    if proxy_url:
        proxies = {
            'http': proxy_url,
            'https': proxy_url,
        }

    # NO usar cookies - sistema simple que detecta FREE delivery vs paid delivery

    try:
        # Paso 1: GET product page para obtener cookies y tokens
        url = f"https://www.amazon.com/dp/{asin}"
        response = session.get(url, timeout=30, proxies=proxies)

        if response.status_code != 200:
            result["error"] = f"HTTP {response.status_code}"
            return result

        html = response.text

        # Extraer CSRF token (necesario para algunas llamadas)
        csrf_token = None
        csrf_match = re.search(r'"anti-csrftoken-a2z"\s*:\s*"([^"]+)"', html)
        if csrf_match:
            csrf_token = csrf_match.group(1)

        # Paso 2: Llamar a API Glow para cambiar zipcode
        glow_url = "https://www.amazon.com/portal-migration/hz/glow/address-change"

        params = {
            'actionSource': 'glow',
            'deviceType': 'desktop',
            'pageType': 'Detail',
            'storeContext': 'pc'
        }

        payload = {
            'locationType': 'LOCATION_INPUT',
            'zipCode': zipcode,
            'deviceType': 'web',
            'storeContext': 'generic',
            'pageType': 'Detail'
        }

        headers = {
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
            'Referer': url
        }

        if csrf_token:
            headers['anti-csrftoken-a2z'] = csrf_token

        # Intentar Glow API con retry en caso de 503
        glow_success = False
        for retry in range(3):  # M√°ximo 3 intentos
            try:
                glow_response = session.post(glow_url, params=params, json=payload, headers=headers, timeout=15, proxies=proxies)

                if glow_response.status_code == 200:
                    glow_success = True
                    break
                elif glow_response.status_code == 503:
                    # 503 Service Unavailable - reintentar despu√©s de 1s
                    if retry < 2:  # Solo esperar si no es el √∫ltimo intento
                        import time
                        time.sleep(1)
                        continue
                else:
                    # Otro error - no reintentar
                    break
            except:
                if retry < 2:
                    import time
                    time.sleep(1)
                    continue
                break

        if not glow_success:
            result["error"] = f"Glow API failed after retries"
            # Continuar de todas formas, intentar parsear lo que haya

        # Paso 3: GET product page nuevamente para obtener delivery dates actualizados
        response = session.get(url, timeout=30, proxies=proxies)

        if response.status_code != 200:
            result["error"] = f"HTTP {response.status_code} (after glow)"
            return result

        html = response.text
        soup = BeautifulSoup(html, 'html.parser')

        # VALIDAR PRIME BADGE (requisito fundamental)
        # Buscar indicadores de que el producto es elegible para Prime
        prime_indicators = [
            # Badge de Prime en delivery section
            r'id="[^"]*prime[^"]*badge',
            r'class="[^"]*prime[^"]*badge',
            # Prime logo
            r'alt="Prime"',
            r'alt="Amazon Prime"',
            # Texto de Prime eligibility
            r'Eligible for.*Prime',
            r'FREE.*delivery.*Prime members',
            r'Prime members get FREE',
            # Data attributes
            r'data-.*prime.*eligible',
        ]

        has_prime_badge = False
        html_lower = html.lower()

        for pattern in prime_indicators:
            if re.search(pattern, html, re.IGNORECASE):
                has_prime_badge = True
                result["prime_available"] = True
                break

        # Extraer precio
        # ESTRATEGIA: Priorizar customerVisiblePrice para precios suprimidos (hidden)
        # Sino, usar m√©todos tradicionales (buybox, a-offscreen, etc.)

        # M√âTODO 1: customerVisiblePrice (para productos con precio suprimido/"Show price")
        # Este es el precio real que Amazon muestra despu√©s de hacer click en "Show price"
        customer_price_match = re.search(r'items\[0\.base\]\[customerVisiblePrice\]\[amount\]" value="([0-9,.]+)"', html)
        if customer_price_match:
            try:
                price_value = customer_price_match.group(1).replace(',', '')
                customer_price = float(price_value)
                if customer_price > 0:
                    result["price"] = customer_price
            except:
                pass

        # Si no encontramos customerVisiblePrice, usar m√©todos tradicionales
        if not result["price"]:
            price_patterns = [
                # Patr√≥n 0: a-offscreen (m√°s confiable, incluye decimales completos)
                (r'<span class="a-offscreen">\$([0-9,.]+)</span>', None),
                # Patr√≥n 1: "a-price-whole">25<" (dollars) + buscar cents despu√©s
                (r'<span class="a-price-whole">([0-9,]+)<', r'<span class="a-price-fraction">([0-9]+)<'),
                # Patr√≥n 2: JSON con precio completo "$25.99"
                (r'"price":\s*"\\$([0-9,.]+)"', None),
            ]

            for whole_pattern, fraction_pattern in price_patterns:
                whole_match = re.search(whole_pattern, html)
                if whole_match:
                    try:
                        dollars = whole_match.group(1).replace(',', '')
                        cents = "00"

                        # Si hay patr√≥n de cents, buscarlo
                        if fraction_pattern:
                            fraction_match = re.search(fraction_pattern, html)
                            if fraction_match:
                                cents = fraction_match.group(1)
                        elif '.' in whole_match.group(1):
                            # Ya tiene decimales (formato "$25.99")
                            parts = whole_match.group(1).replace(',', '').split('.')
                            dollars = parts[0]
                            cents = parts[1] if len(parts) > 1 else "00"

                        result["price"] = float(f"{dollars}.{cents}")
                        break
                    except:
                        pass

        # Verificar disponibilidad
        # ESTRATEGIA MEJORADA: Buscar indicadores fuertes de que se puede comprar
        availability_indicators = [
            "buy new", "add to cart", "add to list",  # Botones de compra
            "in stock", "en stock", "disponible", "available",
            "queda(n)", "qued√°n", "quedan",
            "order within",  # "Order within X hours" indica disponible
        ]

        html_lower = html.lower()
        for indicator in availability_indicators:
            if indicator in html_lower:
                result["in_stock"] = True
                result["available"] = True
                break

        # IMPORTANTE: Si NO encontramos indicadores pero S√ç hay precio Y delivery,
        # entonces est√° disponible (seller alternativo)
        # Solo marcar como unavailable si expl√≠citamente dice unavailable Y no hay precio/delivery

        # Buscar fecha de entrega
        # ESTRATEGIA: Buscar SOLO el PRIMARY delivery message (seller principal/buybox)
        # Ignorar secondary messages, otros sellers, fastest delivery, etc.

        all_dates = []

        # PRIORIDAD 0: Buscar SOLO en PRIMARY_DELIVERY_MESSAGE (LARGE, MEDIUM, o cualquier variante)
        # Este es el bloque del seller principal (buybox winner)
        # Nota: Amazon usa _LARGE, _MEDIUM, etc. dependiendo del contexto

        # Buscar TODO el bloque DELIVERY_BLOCK completo
        # Este contiene todas las opciones de env√≠o (FREE, fastest, etc.)
        delivery_block_pattern = r'<div id="mir-layout-DELIVERY_BLOCK"[^>]*>(.*?)</div></div></div>'
        delivery_block_match = re.search(delivery_block_pattern, html, re.IGNORECASE | re.DOTALL)

        if delivery_block_match:
            delivery_html = delivery_block_match.group(1)

            # Buscar TODAS las ocurrencias de data-csa-c-delivery dentro del bloque
            # Patr√≥n 1: price antes de time
            pattern1 = r'<span[^>]*data-csa-c-delivery-price="([^"]*)"[^>]*data-csa-c-delivery-time="([^"]*)"[^>]*>'
            matches1 = re.findall(pattern1, delivery_html, re.IGNORECASE)

            # Patr√≥n 2: time antes de price
            pattern2 = r'<span[^>]*data-csa-c-delivery-time="([^"]*)"[^>]*data-csa-c-delivery-price="([^"]*)"[^>]*>'
            matches2 = re.findall(pattern2, delivery_html, re.IGNORECASE)

            # Capturar solo FREE delivery (ignorar fastest, paid, etc.)
            for price_type, date_str in matches1:
                if price_type.upper() == "FREE":
                    all_dates.append(('delivery_block', date_str))

            for date_str, price_type in matches2:
                if price_type.upper() == "FREE":
                    all_dates.append(('delivery_block', date_str))

        # Si ya encontramos fechas en data-csa-c attributes, USAR SOLO ESAS
        # NO buscar en el resto del HTML porque puede capturar fechas de otros sellers

        if not all_dates:
            # FALLBACK: Solo si NO encontramos data-csa-c attributes
            # Buscar fecha de Prime (m√°s r√°pida)

            # PRIMERA PRIORIDAD: Detectar same-day/next-day ("hoy", "today", "ma√±ana", "tomorrow")
            pass  # Comentado para evitar capturar fechas incorrectas

        # DESHABILITAR b√∫squedas de fallback para evitar capturar fechas de otros sellers
        if False and not all_dates:
            same_day_patterns = [
                # "miembros Prime reciben entrega GRATIS hoy"
                # "Prime members get FREE delivery today"
                r'(?:miembros?\s+)?Prime\s+(?:members?\s+)?(?:get|reciben)\s+(?:entrega\s+)?(?:GRATIS|FREE)?\s+(?:delivery\s+)?(?:entrega\s+)?(hoy|today)',
                # "FREE delivery today for Prime members"
                r'FREE\s+delivery\s+(today|hoy)\s+for\s+Prime\s+members?',
            ]

            for pattern in same_day_patterns:
                match = re.search(pattern, html, re.IGNORECASE)
                if match:
                    # Same-day delivery detectado
                    from datetime import datetime as dt
                    today = dt.now()
                    today_str = today.strftime("%A, %B %d")  # "Friday, December 20"
                    all_dates.append(('prime', today_str))
                    result["prime_available"] = True
                    break

        # SEGUNDA PRIORIDAD: Next-day delivery
        if not all_dates:
            next_day_patterns = [
                # "miembros Prime reciben entrega GRATIS ma√±ana"
                # "Prime members get FREE delivery tomorrow"
                r'(?:miembros?\s+)?Prime\s+(?:members?\s+)?(?:get|reciben)\s+(?:entrega\s+)?(?:GRATIS|FREE)?\s+(?:delivery\s+)?(?:entrega\s+)?(ma√±ana|tomorrow)',
                # "FREE delivery tomorrow for Prime members"
                r'FREE\s+delivery\s+(tomorrow|ma√±ana)\s+for\s+Prime\s+members?',
            ]

            for pattern in next_day_patterns:
                match = re.search(pattern, html, re.IGNORECASE)
                if match:
                    # Next-day delivery detectado
                    from datetime import datetime as dt, timedelta
                    tomorrow = dt.now() + timedelta(days=1)
                    tomorrow_str = tomorrow.strftime("%A, %B %d")  # "Saturday, December 21"
                    all_dates.append(('prime', tomorrow_str))
                    result["prime_available"] = True
                    break

        # TERCERA PRIORIDAD: Buscar fechas espec√≠ficas de Prime
        if not all_dates:
            prime_patterns = [
                # "FREE delivery Monday, December 29 for Prime members"
                r'FREE\s+delivery\s+((?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),?\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+)\s+for\s+Prime\s+members?',
                # "Or Prime members get FREE delivery Monday, December 22"
                # "Prime members get FREE delivery Sunday, December 21"
                r'Prime\s+members?\s+get\s+FREE\s+delivery\s+((?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),?\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+)',
                # Versi√≥n m√°s flexible sin "FREE"
                r'Prime\s+members?\s+get\s+\w+\s+delivery\s+((?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),?\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+)',
                # "miembros Prime reciben entrega GRATIS el domingo, 21 de diciembre"
                r'miembros?\s+Prime\s+[^<>]{0,100}?entrega[^<>]{0,50}?el\s+((?:lunes|martes|mi√©rcoles|miercoles|jueves|viernes|s√°bado|sabado|domingo),?\s+\d+\s+de\s+(?:enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre))',
            ]

            # Buscar fecha de Prime primero
            for pattern in prime_patterns:
                match = re.search(pattern, html, re.IGNORECASE)
                if match:
                    all_dates.append(('prime', match.group(1).strip()))
                    result["prime_available"] = True
                    break

        # FALLBACK: Buscar fechas de FREE delivery solo si NO encontramos data-csa-c
        if not all_dates:
            # PRIORIDAD 2: Buscar SOLO fechas de FREE delivery (ignorar "fastest delivery" que se paga)
            # IMPORTANTE: Debe decir expl√≠citamente "FREE" en el texto, NO capturar "fastest" o "Or fastest"
            delivery_patterns = [
                # SOLO FREE delivery con rangos "FREE delivery December 26 - 28"
                # Nota: NO captura "Or fastest delivery" o "fastest delivery"
                r'FREE\s+delivery\s+(?:<[^>]+>)?(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+\s*-\s*((?:January|February|March|April|May|June|July|August|September|October|November|December)?\s*\d+)',
                # SOLO FREE delivery con fecha simple "FREE delivery Friday, December 26"
                r'FREE\s+delivery\s+(?:<[^>]+>)?((?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),?\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+)',
                # Atributos data-* con delivery-price="FREE"
                r'data-csa-c-delivery-price="FREE"[^>]*data-csa-c-delivery-time="((?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+(?:\s*-\s*\d+)?)"',
                # Espa√±ol: "entrega GRATIS el s√°bado, 27 de diciembre"
                r'entrega\s+(?:GRATIS|gratis)\s+el\s+((?:lunes|martes|mi√©rcoles|miercoles|jueves|viernes|s√°bado|sabado|domingo),?\s+\d+\s+de\s+(?:enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre))',
            ]

            # Variable para rastrear el √∫ltimo mes visto (para rangos como "December 26 - 28")
            last_seen_month = None

            for pattern in delivery_patterns:
                matches = re.findall(pattern, html, re.IGNORECASE)
                for match_date in matches[:3]:  # Max 3 fechas por patr√≥n
                    date_str = match_date.strip()

                    # Si la fecha es solo un n√∫mero (ej: "28" del rango "December 26 - 28")
                    # Agregarle el mes del contexto
                    if date_str.isdigit():
                        # Buscar el mes en el contexto anterior
                        context_match = re.search(
                            r'(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d+\s*-\s*' + date_str,
                            html,
                            re.IGNORECASE
                        )
                        if context_match:
                            month = context_match.group(1)
                            date_str = f"{month} {date_str}"

                    all_dates.append(('regular', date_str))

        # Si encontramos fechas, elegir la M√ÅS TARD√çA para ser CONSERVADOR
        if all_dates:
            # Si hay fecha de Prime expl√≠cita, usarla
            prime_dates = [d[1] for d in all_dates if d[0] == 'prime']
            if prime_dates:
                result["delivery_date"] = prime_dates[0]
                result["prime_available"] = True
            else:
                # Sino, parsear todas las fechas y elegir la M√ÅS TARD√çA
                # (para ser conservador y evitar aceptar productos que pueden tardar m√°s)
                from datetime import datetime as dt

                parsed_dates = []
                for date_type, date_str in all_dates:
                    try:
                        # Normalizar fecha
                        clean_date = date_str.replace(',', '').strip()

                        # Parsear "Monday December 22" o "December 22" -> date object
                        parts = clean_date.split()

                        month_name = None
                        day_num = None

                        # Intentar encontrar mes y d√≠a
                        for i, part in enumerate(parts):
                            months = {
                                'january': 1, 'february': 2, 'march': 3, 'april': 4,
                                'may': 5, 'june': 6, 'july': 7, 'august': 8,
                                'september': 9, 'october': 10, 'november': 11, 'december': 12
                            }
                            month_num = months.get(part.lower())
                            if month_num and i + 1 < len(parts):
                                try:
                                    day_num = int(parts[i + 1])
                                    month_name = month_num
                                    break
                                except:
                                    pass

                        if month_name and day_num:
                            today = dt.now()
                            year = today.year
                            if month_name < today.month or (month_name == today.month and day_num < today.day):
                                year += 1

                            date_obj = dt(year, month_name, day_num)
                            parsed_dates.append((date_obj, date_str))
                    except:
                        pass

                # Elegir la fecha M√ÅS TEMPRANA (opci√≥n m√°s r√°pida disponible)
                # Si Amazon muestra m√∫ltiples opciones FREE, usar la m√°s r√°pida
                if parsed_dates:
                    earliest = min(parsed_dates, key=lambda x: x[0])
                    result["delivery_date"] = earliest[1]
                elif all_dates:
                    # Fallback: usar la primera fecha encontrada
                    result["delivery_date"] = all_dates[0][1]

        # Calcular d√≠as hasta entrega
        if result["delivery_date"]:
            try:
                date_str = result["delivery_date"].replace(',', '').strip()

                # Si es un rango (ej: "December 24 - 26"), tomar la √öLTIMA fecha (m√°s tard√≠a, conservador)
                if ' - ' in date_str:
                    parts = date_str.split(' - ')
                    # Tomar la parte final del rango
                    end_date = parts[1].strip()

                    # Si la parte final solo tiene el d√≠a (ej: "26" en "December 24 - 26")
                    # Necesita agregar el mes del contexto
                    if end_date.replace(',', '').strip().isdigit():
                        # Extraer el mes de la primera parte
                        start_part = parts[0].strip()
                        for month_word in ['January', 'February', 'March', 'April', 'May', 'June',
                                          'July', 'August', 'September', 'October', 'November', 'December']:
                            if month_word in start_part:
                                end_date = f"{month_word} {end_date}"
                                break

                    date_str = end_date

                # Normalizar espa√±ol -> ingl√©s
                months_es = {
                    'enero': 'January', 'febrero': 'February', 'marzo': 'March',
                    'abril': 'April', 'mayo': 'May', 'junio': 'June',
                    'julio': 'July', 'agosto': 'August', 'septiembre': 'September',
                    'octubre': 'October', 'noviembre': 'November', 'diciembre': 'December'
                }

                for es, en in months_es.items():
                    date_str = date_str.replace(es, en)

                date_str = date_str.replace(' de ', ' ')

                parts = date_str.split()

                month_name = None
                day_num = None

                months = {
                    'jan': 1, 'january': 1, 'feb': 2, 'february': 2,
                    'mar': 3, 'march': 3, 'apr': 4, 'april': 4,
                    'may': 5, 'jun': 6, 'june': 6,
                    'jul': 7, 'july': 7, 'aug': 8, 'august': 8,
                    'sep': 9, 'september': 9, 'oct': 10, 'october': 10,
                    'nov': 11, 'november': 11, 'dec': 12, 'december': 12
                }

                for part in parts:
                    month_num = months.get(part.lower())
                    if month_num:
                        month_name = month_num

                    try:
                        day_num = int(part)
                    except:
                        pass

                if month_name and day_num:
                    today = datetime.now()
                    year = today.year

                    if month_name < today.month or (month_name == today.month and day_num < today.day):
                        year += 1

                    delivery_date = datetime(year, month_name, day_num)
                    days_until = (delivery_date - today).days

                    result["days_until_delivery"] = days_until

                    max_days = int(os.getenv("MAX_DELIVERY_DAYS", "3"))
                    if days_until <= max_days:
                        result["is_fast_delivery"] = True

            except Exception as e:
                result["error"] = f"Error parsing date: {e}"

        # Marcar como disponible si tiene precio Y delivery
        # (suficiente para confirmar que se puede comprar, aunque diga "currently unavailable" para Amazon)
        if result["delivery_date"] and result["price"]:
            result["available"] = True
            result["in_stock"] = True  # Si tiene delivery, est√° disponible

        return result

    except Exception as e:
        result["error"] = str(e)
        return result


if __name__ == "__main__":
    import sys

    test_asin = sys.argv[1] if len(sys.argv) > 1 else "B0FDWT3MXK"
    test_zipcode = sys.argv[2] if len(sys.argv) > 2 else os.getenv("BUYER_ZIPCODE", "33172")

    print("=" * 80)
    print(f"TEST: Verificando disponibilidad con API Glow (R√ÅPIDO)")
    print(f"ASIN: {test_asin}")
    print(f"Zipcode: {test_zipcode}")
    print("=" * 80)
    print()

    import time
    start = time.time()

    result = check_real_availability_glow_api(test_asin, test_zipcode)

    elapsed = time.time() - start

    print("Resultados:")
    print(f"  ‚úÖ Disponible: {result.get('available', False)}")
    print(f"  üì¶ In Stock: {result.get('in_stock', False)}")
    print(f"  ‚≠ê Prime: {result.get('prime_available', False)}")
    print(f"  üí∞ Precio: ${result['price']}" if result.get('price') else "  üí∞ Precio: No encontrado")
    print(f"  üìÖ Fecha entrega: {result.get('delivery_date')}")
    print(f"  ‚è±Ô∏è  D√≠as hasta entrega: {result.get('days_until_delivery')}")
    print(f"  üöÄ Fast delivery (‚â§3d): {result.get('is_fast_delivery', False)}")
    print(f"  ‚ö° Tiempo: {elapsed:.1f}s")

    if result.get('error'):
        print(f"  ‚ö†Ô∏è  Error: {result['error']}")

    print()

    max_days = int(os.getenv("MAX_DELIVERY_DAYS", "3"))

    if result.get('is_fast_delivery'):
        print(f"‚úÖ ACEPTAR - Llega r√°pido (‚â§{max_days} d√≠as)")
    elif result.get('days_until_delivery') and result['days_until_delivery'] > max_days:
        print(f"‚ùå RECHAZAR - Tarda {result['days_until_delivery']} d√≠as (>{max_days}d)")
    else:
        print("‚ö†Ô∏è  No se pudo determinar tiempo de entrega")

    print()
    print("üí° Esta t√©cnica es la que usa software comercial de sync")
    print("   - API interna no documentada de Amazon")
    print("   - 4x m√°s r√°pido que Selenium")
    print("   - No requiere Chrome")
